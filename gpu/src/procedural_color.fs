// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

// expects: blinn_phong, perlin_noise
void main()
{
  vec3 blue = vec3(0.2,0.3,0.8);
  vec3 gray = vec3(0.5,0.45,0.5);
  // Rotate light around the scene at a frequency of 1 revolutions per 8 seconds
  float light_freq = 0.125*2.0*M_PI;
  vec3 l = mat3(view)*normalize(vec3(cos(light_freq*animation_seconds),0.8,(sin(light_freq*animation_seconds))));
  vec3 n = normalize(normal_fs_in);
  vec3 v = normalize(-view_pos_fs_in.xyz);
  float s = sin(20*(sphere_fs_in.y + (1-0.5*float(is_moon))*perlin_noise( sphere_fs_in ))) * 
    (0.991+0.009*perlin_noise( (2.0 + 2*float(is_moon)) * sphere_fs_in));
  float s2 = (
    +0.25*perlin_noise( 1.0 * sphere_fs_in ) 
    +0.25*perlin_noise( 4.0 * sphere_fs_in ) 
    +0.25*perlin_noise( 8.0 * sphere_fs_in ) 
    +0.25*perlin_noise(16.0 * sphere_fs_in ));
  float s3 = max(s+0.4,0) * 
    pow(min(
  (0.5+0.5*(
    (0.2*sin(10*(sphere_fs_in.x + perlin_noise( 8*sphere_fs_in )))+
    0.2*sin(15*(sphere_fs_in.z + perlin_noise( 8*sphere_fs_in )))
  + 0.2*perlin_noise(16*sphere_fs_in))
  + 0.6*perlin_noise(32*sphere_fs_in)
  ))
  ,1.0),2);
  float b = 1-clamp( 0.1*pow(s*0.5+0.5,20) + 0.7*(0.5*s2+0.5) + 0.2*s3, 0,1) ;
  color = blinn_phong(
    clamp(b,0,1)*mix(blue,gray,float(is_moon)),
    clamp(b,0,1)*mix(blue,gray,float(is_moon)),
    vec3(1,1,1),
    1000.0,
    n,
    v,
    l);
}
